<!DOCTYPE html>
<!-- 
  Companion viewer for Arelle plugin loadFromPDF.
  (c) Copyright 2011-present Workiva, Inc.
  Licensed under the Apache License, Version 2.0
  
  Use: run under a local viewer with a json instance provided by loadFromPDF like this:
    URL: http://localhost:52785/1/inlinePdfViewer.html?doc=myFile.json (from loadFromPDF)
    (one may use an Arelle LocalViewer as with EDGAR local operation.)
    (requires these Mozilla files: pdf.mjs, pdf.mjs.map, pdf.worker.mjs, pdf.worker.mjs.map)
 
 Careat: This is a proof-of-concept viewer, not a production product.
 -->
<html>
<head>
  <meta charset="UTF-8">
  <title>XBRL Tagged PDF inline viewer example</title>
</head>
<body>

<div>
  <button id="prev">Previous</button>
  <button id="next">Next</button>
  &nbsp; &nbsp;
  <span>Page: <span id="page_num"></span> / <span id="page_count"></span></span>
</div>
<div>
<canvas id="ixv-canvas" style="border: 1px solid red; direction: ltr; position:absolute; left:0px; top:30px; z-index: 2"></canvas>
<canvas id="pdf-canvas" style="border: 1px solid black; direction: ltr; position:absolute; left:0px; top:30px; z-index: 1"></canvas>
</div>


<!--<script src="../../node_modules/pdfjs-dist/build/pdf.mjs" type="module"></script>-->
<script src="pdf.mjs" type="module"></script>

<script id="script" type="module">
  //
  // If absolute URL from the remote server is provided, configure the CORS
  // header on that server.
  //
  // check for ?doc= parameter to load first (pdf or json instance)
  const urlPattern = /\?doc=([^&]+)$/;
  var entryUrl, pdfUrl = null;
  var ixTarget = null, ixFacts = null, ixTextFields = null, ixFormFields = null;
  var ixMcidFacts = null, ixFormFields = null, rectFactIds = null;
  
  // pdf vars
  var pdf = null;
  const scale = 1.85;
  const vScale = scale * 2;
  // Support HiDPI-screens.
  const outputScale = window.devicePixelRatio || 1;

  // ixviewer canvas and context for drawing fact outlines and receiving clicks
  const ixvCanvas = document.getElementById("ixv-canvas");
  const ixvContext = ixvCanvas.getContext("2d");
  // pdf viewing canvas
  const pdfCanvas = document.getElementById("pdf-canvas");
  const pdfContext = pdfCanvas.getContext("2d");
  
  var ixvLeft = 0, ixvTop = 0, vTop = 0, fTop = 0,
      pageRendering = false, pageNumPending = null, pageNum = 1	;
   
  if (urlPattern.test(location.href)) {
     entryUrl = location.href.match(urlPattern)[1];
  } else {
	 entryUrl = './apple-10-Q4-2024-As-Filed-2pgAcrobat-Tagged.pdf';
  }
  if (entryUrl.endsWith(".json")) {
    let xhr = new XMLHttpRequest();
    var loadingErr = null;
    xhr.onreadystatechange = function() {
        if (this.readyState == 4) {
            if (this.status == 200) {
                const oimInst = JSON.parse(this.responseText);
                if (!(typeof oimInst === 'object' && "documentInfo" in oimInst)) {
                   loadingErr = "Json loaded is not an OIM instance objects";
                } else if (oimInst.documentInfo.documentType != "https://xbrl.org/2021/xbrl-json") {
                   loadingErr = "Json loaded does not have OIM json instance documentType";
                } else if (!("pdfMapping" in oimInst && "file" in oimInst["pdfMapping"])) {
                   loadingErr = "Json loaded does not have pdfMapping object";
                } else {
                   const pdfMapping = oimInst.pdfMapping;
                   pdfUrl = pdfMapping.file;
                   ixTarget = pdfMapping.target;
                   ixFacts = oimInst.facts;
                   ixTextFields = pdfMapping.ixTextFields;
                   ixFormFields = pdfMapping.ixFormFields;
                   console.log("oim json instance loaded successfully");
                   startupPdf();
                }
            } else {
                loadingErr = "Unable to read OIM json instance";
            }
            if (loadingErr) {
              alert(loadingErr);
              console.log(loadingErr);
            }
        }
    };
    xhr.ontimeout = function() {
        alert("Timeout reading OIM json instance");
    };
    xhr.open("GET", entryUrl, true);
    xhr.timeout = 2000; // milliseconds
    xhr.send();
  } else {
    pdfUrl = entryUrl;
    startupPdf();
  }

  /**
   * Get page info from document, resize canvas accordingly, and render page.
   * @param num Page number.
   */
  function renderPage(num) {
    pageRendering = true;
    // Using promise to fetch the page
    pdf.getPage(num).then(function(page) {
      var viewport = page.getViewport({scale: scale});
      pdfCanvas.width = Math.floor(viewport.width * outputScale);
      pdfCanvas.height = Math.floor(viewport.height * outputScale);
      pdfCanvas.style.width = Math.floor(viewport.width) + "px";
      pdfCanvas.style.height = Math.floor(viewport.height) + "px";

      ixvCanvas.width = pdfCanvas.width ;
      ixvCanvas.height = pdfCanvas.height;
      ixvCanvas.style.width = pdfCanvas.style.width;
      ixvCanvas.style.height = pdfCanvas.style.height;
 	  ixvLeft = ixvCanvas.offsetLeft + ixvCanvas.clientLeft;
  	  ixvTop = ixvCanvas.offsetTop + ixvCanvas.clientTop;
  
      vTop = viewport.viewBox[3]; // y height unscaled
      fTop = vTop + 0;
      
      var transform = outputScale !== 1
          ? [outputScale, 0, 0, outputScale, 0, 0]
          : null;
      //
      // Render PDF page into canvas context
      //
      var renderContext = {
        canvasContext: pdfContext,
        transform,
        viewport,
      };
      var renderTask = page.render(renderContext);

      // Wait for rendering to finish
      renderTask.promise.then(function() {
        pageRendering = false;
        if (pageNumPending !== null) {
          // New page rendering is pending
          renderPage(pageNumPending);
          pageNumPending = null;
        }
      rectFactIds = null;
      page.getTextContent( { includeMarkedContent: true } ).then(function(textContent) {
       if (ixTextFields && ixFormFields) {
          console.log("textContent with ix text and form mapping");
          let currentPagePrefix = "p" + page._pageInfo.ref.num + "R";
          rectFactIds = []; // [  [x,y,w,h, [factIds]], ... ] 
          let mcidFactIds = {};
		  Object.entries(ixTextFields).forEach(([factId, mcids]) => {
              for (const mcid of mcids) {
                 if (mcid.startsWith(currentPagePrefix)) {
                   if (!(mcid in mcidFactIds)) mcidFactIds[mcid] = [];
                   mcidFactIds[mcid].push(factId);
                 }
              }
		  });
		  var mcid = null, tag = null;
          for (const t of textContent.items) {
            if (t.type == "beginMarkedContentProps") {
               mcid = t.id;
               tag = t.tag;
            } else if (t.type == "endMarkedContent") {
               mcid = null;
               tag = null;
            } else {
				if (mcid in mcidFactIds && t.width > 0 && t.height > 0) {
				  rectFactIds.push( [ t.transform[4], t.transform[5], t.width, t.height, mcidFactIds[mcid] ] )
				}
			}
          }
          for (const ixFormField of ixFormFields) { // factID, page, x, y, w, h
            if (ixFormField[1] == currentPagePrefix) {
              rectFactIds.push( [ ixFormField[2], 
              					  ixFormField[3], 
              					  ixFormField[4] - ixFormField[2], 
              					  ixFormField[5] - ixFormField[3], 
              					  [ ixFormField[0] ] ] );
            }
          }
	      ixvContext.strokeStyle = "red";
          for (const r of rectFactIds) { // x, y, w, h, [factIDs]
            // pad by 1 on all sides
			ixvContext.strokeRect((r[0]-2) * vScale, (vTop - r[1]+2) * vScale	, (r[2]+3) * vScale, (-r[3]-2) * vScale);  
          }
       } else {
          console.log("textContent but no ix text or form mapping available");
       }
      });
       
      });
   })
    // Update page counters
    document.getElementById('page_num').textContent = num;
  };

  function startupPdf() {
    //
    // The workerSrc property shall be specified.
    //
    //pdfjsLib.GlobalWorkerOptions.workerSrc =
    //  '../../node_modules/pdfjs-dist/build/pdf.worker.mjs';
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      './pdf.worker.mjs';
    //
    // Asynchronous download PDF
    //
    pdfjsLib.getDocument(pdfUrl).promise.then(function(_pdf) {
      pdf = _pdf;
      document.getElementById('page_count').textContent = pdf.numPages;

      // Initial/first page rendering
      renderPage(1);
    });
  } // end startupPDF

   
  /**
   * If another page rendering in progress, waits until the rendering is
   * finised. Otherwise, executes rendering immediately.
   */
  function queueRenderPage(num) {
    if (pageRendering) {
      pageNumPending = num;
    } else {
      renderPage(num);
    }
  }

  /**
   * Displays previous page.
   */
  function onPrevPage() {
    if (pageNum <= 1) {
      return;
    }
    pageNum--;
    queueRenderPage(pageNum);
  }
  document.getElementById('prev').addEventListener('click', onPrevPage);

  /**
   * Displays next page.
   */
  function onNextPage() {
    if (pageNum >= pdf.numPages) {
      return;
    }
    pageNum++;
    queueRenderPage(pageNum);
  }
  document.getElementById('next').addEventListener('click', onNextPage);

  // Add event listener for `click` events.
  ixvCanvas.addEventListener('click', function(event) {
    var x = event.pageX - ixvLeft,
        y = event.pageY - ixvTop;

    let vX = x / scale;
    let vY = vTop - y / scale;
    console.log("click at x=" + x + " y=" + y + " vx=" + 
                vX + " vy=" + vY);
    if (rectFactIds) {
       var facts = "", factIds = "";
       for (const r of rectFactIds) { // x, y, w, h, factIDs
           if (vX >= r[0] && vX <= r[0] + r[2] && vY >= r[1] && vY <= r[1] + r[3]) {
               // fact is highlighted, add to fact window
               for (const factId of r[4]) {
                 facts += JSON.stringify(ixFacts[factId], undefined, 2) + "\n";
                 factIds += ((factIds) ? ", " : "") + factId;
               }
           }
       }
       console.log("  facts: " + factIds);
       document.getElementById('facts').textContent = facts;
       if (facts) {
         alert(facts);
       }
    }

  }, false);
</script>

<hr>
<h2>Selected facts:</h2>
<pre id="facts"></pre>
</body>
</html>
